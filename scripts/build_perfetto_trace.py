"""
Script to build a Perfetto Trace from a run directory with input/output YAML files.
"""
import argparse
import glob
import logging
import os

from typing import (
    Any,
    Dict,
    List,
)

from hagent.core.step import Step
from hagent.core.tracer import (
    HAGENT_ID,
    LLM_ID,
    PhaseType,
    Tracer,
    TraceEvent,
    s_to_us,
)

logger = logging.getLogger(__name__)

def parse_arguments() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description='Perfetto trace builder using a directory of Step input/outputs.')
    parser.add_argument(
        '-i',
        '--input-dir',
        type=str,
        required=True,
        help='Scans this directory for YAML files generated by Steps.'
    )
    parser.add_argument(
        '--asynchronous',
        action='store_true',
        help='Builds a Perfetto trace that displays Steps as parallel as possible.'
    )
    parser.add_argument(
        '-o',
        '--output-file',
        type=str,
        default='perfetto.json',
        help='Name of the output Perfetto Trace.'
    )
    return parser

def scan_for_files(run_dir: str) -> List[str]:
    return glob.glob(f"{run_dir}/*.yaml")

def get_data_from_yaml(yaml_f: str) -> Dict[Any, Any]:
    return

def generate_perfetto_trace(yaml_files: List[str], output_file: str, asynchronous: bool):
    """
    Generates a Perfetto Trace given all relevant YAML files.

    Args:
        yaml_files: The list of relevant YAML files to include in the trace.
        output_file: The output file to dump the Perfetto Trace to.
        asynchronous: Disregard the actual execution and display an asynchronous ordering.

    """
    step = Step()

    # Initial YAMLs used as inputs for a Pipe.
    initial = set()
    inputs = set()
    outputs = set()
    for idx, f in enumerate(yaml_files):
        step.input_file = f
        data = step.read_input()
        if data.keys == ["error"]:
            logger.exception("Failure detected in step!")

        # If there is no 'perfetto' key, it may be one of two cases.
        # - Initial input YAML
        # - Non-relevant YAML
        if data.get("perfetto", None) is None:
            initial.add(os.path.basename(f))
            continue

        # Track the inputs/output YAMLs.
        inputs.add(data["perfetto"]["input"])
        outputs.add(data["perfetto"]["output"])
        # Log the Step itself.
        Tracer.log(TraceEvent(
            name = data["step"],
            cat = "hagent",
            ph = PhaseType.COMPLETE,
            ts = s_to_us(data["perfetto"]["start"]),
            pid = HAGENT_ID,
            tid = 0,
            dur = s_to_us(data["perfetto"]["elapsed"]),
        ))

        # Log any LLM calls made by LLM_wrap during the Step.
        if data["perfetto"].get("history", None):
            for llm_call in data["perfetto"]["history"]:
                Tracer.log(TraceEvent(
                    name = llm_call["id"],
                    cat = "hagent",
                    ph = PhaseType.COMPLETE,
                    ts = s_to_us(llm_call["created"]),
                    pid = LLM_ID,
                    tid = 0,
                    dur = s_to_us(llm_call["elapsed"]),
                ))

    logger.debug(f"Initial YAML files: %s", initial)
    logger.debug(f"Input YAML files: %s", inputs)
    logger.debug(f"Output YAML files: %s", outputs)

    # Log the dependency flow.
    # This draws an arrow going from the input to the output.
    for _, f in enumerate(yaml_files):
        if os.path.basename(f) in initial:
            continue

        step.input_file = f
        data = step.read_input()
        if data.keys == ["error"]:
            logger.exception("Failure detected in step!")


        # TODO: If input is multiple YAMLs, we should use set intersection.
        # If the set intersection yields at least one element, we have a dependency.

        # TODO: figure out support for multi-pipe flows.
        flow_name = "pipe"

        # If the input of this Step was an initial configuration file,
        # this step has no dependencies.
        if data["perfetto"]["input"] in initial:
            Tracer.log(TraceEvent(
                name = flow_name,
                cat = "hagent",
                ph = PhaseType.FLOW_START,
                ts = s_to_us(data["perfetto"]["start"]),
                pid = HAGENT_ID,
                tid = 0,
                id = 1)
            )
        # If the output of this Step was an input of another Step,
        # then we know this is an intermediate Step.
        elif data["perfetto"]["output"] in inputs:
            Tracer.log(TraceEvent(
                name = flow_name,
                cat = "hagent",
                ph = PhaseType.FLOW_STEP,
                ts = s_to_us(data["perfetto"]["start"]),
                pid = HAGENT_ID,
                tid = 0,
                id = 1)
            )
        else:
            Tracer.log(TraceEvent(
                name = flow_name,
                cat = "hagent",
                ph = PhaseType.FLOW_END,
                ts = s_to_us(data["perfetto"]["start"]),
                pid = HAGENT_ID,
                tid = 0,
                id = 1,
                bp="e")
            )

    Tracer.save_perfetto_trace(output_file, not asynchronous)

def main():
    parser = parse_arguments()
    args = parser.parse_args()

    logging.basicConfig(filename="perfetto_trace.log", level=logging.INFO)

    yaml_files = scan_for_files(args.input_dir)
    logger.info("Gathered YAML files: %s" % yaml_files)
    generate_perfetto_trace(yaml_files, args.output_file, args.asynchronous)
    logger.info("Finished generated Perfetto trace: [%s]", args.output_file)

if __name__ == "__main__":
    main()
