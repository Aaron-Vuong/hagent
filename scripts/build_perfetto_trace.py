"""
Script to build a Perfetto Trace from a run directory with input/output YAML files.
"""
import argparse
import glob
import logging
import os

from typing import (
    Any,
    Dict,
    List,
    Tuple,
)

from hagent.core.step import Step
from hagent.core.tracer import (
    HAGENT_PID,
    LLM_PID,
    HAGENT_TID,
    LLM_TID,
    METADATA_TID,
    PhaseType,
    Tracer,
    TraceEvent,
    s_to_us,
    read_yaml,
)

logger = logging.getLogger(__name__)

def parse_arguments() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description='Perfetto trace builder using a directory of Step input/outputs.')
    parser.add_argument(
        '-i',
        '--input-dir',
        type=str,
        required=True,
        help='Scans this directory for YAML files generated by Steps.'
    )
    parser.add_argument(
        '--asynchronous',
        action='store_true',
        help='Builds a Perfetto trace that displays Steps as parallel as possible.'
    )
    parser.add_argument(
        '-o',
        '--output-file',
        type=str,
        default='perfetto.json',
        help='Name of the output Perfetto Trace.'
    )
    return parser

def scan_for_files(run_dir: str) -> List[str]:
    return glob.glob(f"{run_dir}/*.yaml")

def get_data_from_yaml(yaml_f: str) -> Dict[Any, Any]:
    return

def parse_yaml_files(yaml_files: List[str]) -> Tuple[set, set, set]:
    """
    Parses the YAML files for the initial hierarchy of Steps + Tool Calls.

    Args:
        yaml_files: The list of relevant YAML files to include in the trace.
    
    Returns:
        The dependencies files listed in each YAML under data['tracing']['input']
        or data['tracing']['output'].

    """
    initial = set()
    inputs = set()
    outputs = set()
    step_id = 0
    for idx, f in enumerate(yaml_files):
        data = read_yaml(f)
        if data.keys == ["error"]:
            logger.exception("Failure detected in step!")

        # If there is no 'tracing' key, it may be one of two cases.
        # - Initial input YAML
        # - Non-relevant YAML
        if data.get('tracing', None) is None:
            initial.add(os.path.basename(f))
            continue

        # Track the inputs/output YAMLs.
        inputs.add(data['tracing']["input"])
        outputs.add(data['tracing']["output"])
        # Log the Step itself.

        # Start from the __init__
        ts = data['tracing']['trace_events'][0]["ts"]
        additional_dur = data['tracing']['start'] - ts

        # Log any LLM calls made by LLM_wrap during the Step.
        if data['tracing'].get("history", None):
            for llm_call in data['tracing']["history"]:
                Tracer.log(TraceEvent(
                    name = llm_call["id"],
                    cat = "llm",
                    ph = PhaseType.COMPLETE,
                    ts = s_to_us(llm_call["created"]),
                    pid = LLM_PID,
                    tid = LLM_TID,
                    args = {
                        "step_id": step_id,
                        "data": llm_call
                    },
                    dur = s_to_us(llm_call["elapsed"]),
                ))

        # Log any TraceEvents recorded during the Step.
        if data['tracing'].get("trace_events", None):
            for trace_event in data['tracing']["trace_events"]:
                trace_event["args"]["step_id"] = step_id
                Tracer.log(TraceEvent(**trace_event))


        # Log the actual step() call.
        Tracer.log(TraceEvent(
            name = f"{data['step']}::step",
            cat = "hagent",
            ph = PhaseType.COMPLETE,
            ts = data['tracing']["start"],
            pid = HAGENT_PID,
            tid = HAGENT_TID,
            args = {
                "step_id": step_id,
            },
            dur = data['tracing']["elapsed"],
        ))

        # Then log the overarching Step execution.
        ## We add a slight offset (0.3 us) so that Flow events
        ## can pick up the overall Step instead of the __init__
        ## function.
        marker_offset = 0.3
        Tracer.log(TraceEvent(
            name = data["step"],
            cat = "hagent.step",
            ph = PhaseType.COMPLETE,
            ts = ts - marker_offset,
            pid = HAGENT_PID,
            tid = HAGENT_TID,
            args = {
                "step_id": step_id,
                "data": data
            },
            dur = data['tracing']["elapsed"] + additional_dur + marker_offset,
        ))

        step_id += 1
    return (initial, inputs, outputs)

def generate_perfetto_trace(yaml_files: List[str], output_file: str, asynchronous: bool):
    """
    Generates a Perfetto Trace given all relevant YAML files.

    Args:
        yaml_files: The list of relevant YAML files to include in the trace.
        output_file: The output file to dump the Perfetto Trace to.
        asynchronous: Disregard the actual execution and display an asynchronous ordering.

    """

    # Initial YAMLs used as inputs for a Pipe.
    initial, inputs, outputs = parse_yaml_files(yaml_files)

    logger.debug(f"Initial YAML files: %s", initial)
    logger.debug(f"Input YAML files: %s", inputs)
    logger.debug(f"Output YAML files: %s", outputs)

    Tracer.save_perfetto_trace(
        dependencies=(initial, inputs, outputs),
        filename=output_file,
        asynchronous=asynchronous)

def main():
    parser = parse_arguments()
    args = parser.parse_args()

    logging.basicConfig(filename="perfetto_trace.log", level=logging.INFO)

    yaml_files = scan_for_files(args.input_dir)
    logger.info("Gathered YAML files: %s" % yaml_files)
    generate_perfetto_trace(yaml_files, args.output_file, args.asynchronous)
    logger.info("Finished generated Perfetto trace: [%s]", args.output_file)

if __name__ == "__main__":
    main()
