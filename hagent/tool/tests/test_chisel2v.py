# tests/test_chisel2v.py
# See LICENSE file for details

import pytest
from hagent.tool.chisel2v import Chisel2v


def test_setup_success(tmp_path):
    # In real usage, ensure 'sbt' is available in PATH or provide a mock path
    # Here we mock it by creating a dummy 'sbt' file
    sbt_dir = tmp_path / 'fake_sbt_dir'
    sbt_dir.mkdir()
    sbt_bin = sbt_dir / 'sbt'
    sbt_bin.write_text("#!/usr/bin/env bash\necho 'Fake sbt running'\n")
    sbt_bin.chmod(0o755)

    dut = Chisel2v()
    ok = dut.setup(str(sbt_dir))
    assert ok is True
    assert dut._is_ready is True
    assert dut.error_message == ''


def test_setup_failure(tmp_path):
    dut = Chisel2v()

    assert dut.error_message == ''

    ok = dut.setup('/non/existent/path')

    assert not ok
    assert dut._is_ready is False
    assert dut.error_message != ''


def test_generate_verilog_not_ready():
    dut = Chisel2v()
    with pytest.raises(RuntimeError):
        dut.generate_verilog('class MyModule extends Module {}', 'MyModule')


def test_chisel_fix_basic():
    dut = Chisel2v()
    code = """
class FooModule extends Module {
  val io = IO(new Bundle {})
}
"""
    fixed = dut.chisel_fix(code, 'FooModule')
    assert 'import chisel3.util._' in fixed
    assert 'import _root_.circt.stage.ChiselStage' in fixed
    assert 'object Top extends App' in fixed
    assert 'new FooModule' in fixed


def test_generate_verilog_success():
    # Put a fake chisel2v_build.sbt in the same folder as chisel2v.py or patch it

    dut = Chisel2v()
    ok = dut.setup()
    assert ok

    # Minimal valid Chisel code
    code = """
import chisel3._
class MyModule extends Module {
  val io = IO(new Bundle {
    val in = Input(UInt(6.W))
    val ou = Output(UInt(6.W))
  })
  io.ou := io.in
}

"""

    out_txt = dut.generate_verilog(code, 'MyModule')

    assert 'Generated by CIRCT' in out_txt
    assert 'module MyModule' in out_txt
