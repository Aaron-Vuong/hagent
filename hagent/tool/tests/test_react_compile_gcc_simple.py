#!/usr/bin/env python3
"""
Iterative C++ compile fix using GCC and LLM_wrap.
This script uses React to drive iterations where GCC is invoked
to check code syntax and an LLM wrapper is used to generate fixes.
"""

import os
import re
import subprocess
import tempfile
from typing import List

from hagent.tool.react import React
from hagent.tool.compile import Diagnostic
from hagent.core.llm_wrap import LLM_template, LLM_wrap


def extract_errors(gcc_output: str) -> list:
    """
    Extracts GCC errors (including context) from compiler output.

    Args:
        gcc_output: The compiler output string.

    Returns:
        A list of error block strings. Each block includes an error line and its context.
    """
    error_blocks = []
    current_block = None

    for line in gcc_output.splitlines():
        # Start a new error block if the line contains 'error:'
        if re.match(r'.*error:', line):
            if current_block:
                error_blocks.append(current_block)
            current_block = line + '\n'
        elif current_block:
            # Continuation of the current error block.
            current_block += line + '\n'
    if current_block:
        error_blocks.append(current_block)
    return error_blocks


def check_callback_cpp(code: str) -> List[Diagnostic]:
    """
    Checks if the provided C++ code compiles using g++ in syntax-check mode.

    Returns a list of Diagnostic objects if errors are found; an empty list otherwise.
    """
    with tempfile.NamedTemporaryFile(delete=False, suffix='.cpp') as tmp:
        tmp_name = tmp.name
        tmp.write(code.encode('utf-8'))

    try:
        # Run g++ in syntax-check mode (-fsyntax-only) without linking.
        result = subprocess.run(['g++', '-std=c++17', '-fsyntax-only', tmp_name], capture_output=True, text=True)
        if result.returncode != 0:
            diags = []
            for msg in extract_errors(result.stderr):
                # Create a Diagnostic with the error message.
                diags.append(Diagnostic(msg))
            return diags
        return []
    finally:
        if os.path.exists(tmp_name):
            os.remove(tmp_name)


def fix_callback_cpp(current_code: str, diag: Diagnostic, fix_example: str, iteration_count: int) -> str:
    """
    Calls the LLM wrapper to fix the C++ code based on a given diagnostic.

    Constructs a prompt incorporating the diagnostic message and the current code,
    then returns the fixed code generated by the LLM. If no fix is provided,
    returns the original code.
    """
    # Construct a prompt that includes the error message and current code.
    prompt = (
        f'The following C++ code produced the error:\n\n'
        f'{diag.msg}\n{diag.hint}\n\n'
        'Please fix the code below to resolve the error. Return only the corrected code.\n\n'
        f'{current_code}\n'
    )
    # Determine the path to the LLM configuration file.
    conf_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'llm_wrap_conf_compile.yaml')
    # Create an LLM template for code fixes.
    template = LLM_template(
        [
            {'role': 'system', 'content': 'You are an expert C++ code fixer.'},
            {'role': 'user', 'content': '{gen_msg}'},
        ]
    )
    # Initialize the LLM_wrap instance.
    lw = LLM_wrap()
    lw.from_file(name='cpp_fix', log_file='llm_fix_cpp.log', conf_file=conf_file, init_template=template, chat_template=template)
    # Call inference with the constructed prompt.
    results = lw.inference({'gen_msg': prompt}, n=1)
    if results and len(results) > 0:
        fixed_code = results[0]
        # Return the fixed code if it differs from the current code.
        if fixed_code and fixed_code.strip() != current_code.strip():
            return fixed_code
    return current_code


if __name__ == '__main__':
    # Initialize React.
    react_tool = React()
    setup_success = react_tool.setup(db_path='foo.yaml', learn=True, max_iterations=3)
    if not setup_success:
        print(f'React setup failed: {react_tool.error_message}')
        exit(1)

    # A C++ snippet with a missing semicolon.
    faulty_code = r"""
#include <iostream>

int main() {
    std::cout << "Hello World" << std::endl
    return 0;
}
"""

    # Run the React cycle with the provided callbacks.
    fixed_code = react_tool.react_cycle(faulty_code, check_callback_cpp, fix_callback_cpp)

    # Print results.
    if fixed_code:
        print('Successfully fixed code:\n')
        print(fixed_code)
    else:
        print('Could not fix the code within the iteration limits.')
